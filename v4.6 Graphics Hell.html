<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Raycaster Maze</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            background-color: #000;
            border: 2px solid #fff;
        }

        #game-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            padding: 20px;
            text-align: center;
            font-size: 2em;
            display: none;
            z-index: 10;
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="message-box"></div>
    </div>
    <div id="controls">
        <p><strong>Controls:</strong></p>
        <p>Move: <strong>W/S</strong> or <strong>Up/Down</strong> Arrows</p>
        <p>Turn: <strong>A/D</strong> or <strong>Left/Right</strong> Arrows</p>
        <p>Sprint: <strong>Shift</strong></p>
    </div>

    <script>
        window.onload = function() {
            // --- SETUP ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const messageBox = document.getElementById('message-box');
            const gameContainer = document.getElementById('game-container');

            const screenWidth = gameContainer.offsetWidth * 0.9;
            const screenHeight = gameContainer.offsetHeight * 0.9;
            canvas.width = screenWidth;
            canvas.height = screenHeight;

            showMessage("Loading...");

            const map = [
                "####################",
                "#..................#",
                "#S.................#",
                "#..................#",
                "#..........####....#",
                "#..#..#..###.......#",
                "#.....####.........#",
                "#..................#",
                "#..................#",
                "####...............#",
                "#..#..#..###.......#",
                "####..####.........#",
                "#..................E",
                "#..................#",
                "####################",
            ];
            const mapWidth = map[0].length;
            const mapHeight = map.length;

            let endPoint = null;

            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (map[y][x] === 'E') {
                        endPoint = {
                            x: x,
                            y: y
                        };
                        break;
                    }
                }
                if (endPoint) {
                    break;
                }
            }

            const player = {
                x: 2.5,
                y: 2.5,
                dirX: 1,
                dirY: 0,
                planeX: 0,
                planeY: 0.66,
                moveSpeed: 0.05,
                rotSpeed: 0.03
            };

            let gameWon = false;
            const keys = {};
            let isSprinting = false;

            // Create a simple brick-like texture programmatically
            const textureWidth = 64;
            const textureHeight = 64;
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = textureWidth;
            textureCanvas.height = textureHeight;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Draw brick pattern
            textureCtx.fillStyle = '#8B4513'; // Brown
            textureCtx.fillRect(0, 0, textureWidth, textureHeight);
            
            textureCtx.fillStyle = '#A0522D'; // SaddleBrown
            for (let y = 0; y < textureHeight; y += 8) {
                for (let x = (y % 16 === 0) ? 0 : 8; x < textureWidth; x += 16) {
                    textureCtx.fillRect(x, y, 8, 4);
                }
            }
            
            textureCtx.fillStyle = '#654321'; // Darker brown
            for (let i = 0; i < 200; i++) {
                const x = Math.floor(Math.random() * textureWidth);
                const y = Math.floor(Math.random() * textureHeight);
                textureCtx.fillRect(x, y, 1, 1);
            }
            
            // Get texture data
            const textureData = textureCtx.getImageData(0, 0, textureWidth, textureHeight);

            // Hide loading message and start game
            hideMessage();
            gameLoop();

            // --- EVENT LISTENERS ---
            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.shiftKey) {
                    isSprinting = true;
                }
            });
            document.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (!e.shiftKey) {
                    isSprinting = false;
                }
            });

            window.addEventListener('resize', () => {
                const newWidth = gameContainer.offsetWidth * 0.9;
                const newHeight = gameContainer.offsetHeight * 0.9;
                canvas.width = newWidth;
                canvas.height = newHeight;
                render();
            });

            // --- GAME LOOP ---
            function gameLoop() {
                if (!gameWon) {
                    handleInput();
                    checkWinCondition();
                    render();
                    requestAnimationFrame(gameLoop);
                }
            }

            // --- INPUT HANDLING ---
            function handleInput() {
                const boostSpeed = isSprinting ? player.moveSpeed * 1.5 : player.moveSpeed;
                const rotSpeed = player.rotSpeed;

                let newX = player.x;
                let newY = player.y;

                if (keys['KeyW'] || keys['ArrowUp']) {
                    newX = player.x + player.dirX * boostSpeed;
                    newY = player.y + player.dirY * boostSpeed;
                }
                if (keys['KeyS'] || keys['ArrowDown']) {
                    newX = player.x - player.dirX * boostSpeed;
                    newY = player.y - player.dirY * boostSpeed;
                }

                if (map[Math.floor(player.y)][Math.floor(newX)] !== '#') {
                    player.x = newX;
                }

                if (map[Math.floor(newY)][Math.floor(player.x)] !== '#') {
                    player.y = newY;
                }

                if (keys['KeyA'] || keys['ArrowLeft']) {
                    const oldDirX = player.dirX;
                    player.dirX = player.dirX * Math.cos(-rotSpeed) - player.dirY * Math.sin(-rotSpeed);
                    player.dirY = oldDirX * Math.sin(-rotSpeed) + player.dirY * Math.cos(-rotSpeed);
                    const oldPlaneX = player.planeX;
                    player.planeX = player.planeX * Math.cos(-rotSpeed) - player.planeY * Math.sin(-rotSpeed);
                    player.planeY = oldPlaneX * Math.sin(-rotSpeed) + player.planeY * Math.cos(-rotSpeed);
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    const oldDirX = player.dirX;
                    player.dirX = player.dirX * Math.cos(rotSpeed) - player.dirY * Math.sin(rotSpeed);
                    player.dirY = oldDirX * Math.sin(rotSpeed) + player.dirY * Math.cos(rotSpeed);
                    const oldPlaneX = player.planeX;
                    player.planeX = player.planeX * Math.cos(rotSpeed) - player.planeY * Math.sin(rotSpeed);
                    player.planeY = oldPlaneX * Math.sin(rotSpeed) + player.planeY * Math.cos(rotSpeed);
                }
            }

            // --- WIN CONDITION CHECK ---
            function checkWinCondition() {
                const distToEnd = Math.sqrt(Math.pow(player.x - endPoint.x, 2) + Math.pow(player.y - endPoint.y, 2));
                if (distToEnd < 0.5) {
                    gameWon = true;
                    showMessage("You Win!");
                }
            }

            // --- DISPLAY MESSAGE ---
            function showMessage(text) {
                messageBox.textContent = text;
                messageBox.style.display = 'block';
            }

            function hideMessage() {
                messageBox.style.display = 'none';
            }

            // --- RENDERING ---
            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#404040';
                ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
                ctx.fillStyle = '#964B00';
                ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

                // Create image data for entire screen for efficient pixel manipulation
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;

                for (let x = 0; x < canvas.width; x++) {
                    const cameraX = 2 * x / canvas.width - 1;
                    const rayDirX = player.dirX + player.planeX * cameraX;
                    const rayDirY = player.dirY + player.planeY * cameraX;

                    let mapX = Math.floor(player.x);
                    let mapY = Math.floor(player.y);

                    const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1 / rayDirX);
                    const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1 / rayDirY);

                    let sideDistX;
                    let sideDistY;

                    const stepX = (rayDirX < 0) ? -1 : 1;
                    const stepY = (rayDirY < 0) ? -1 : 1;

                    if (rayDirX < 0) {
                        sideDistX = (player.x - mapX) * deltaDistX;
                    } else {
                        sideDistX = (mapX + 1.0 - player.x) * deltaDistX;
                    }
                    if (rayDirY < 0) {
                        sideDistY = (player.y - mapY) * deltaDistY;
                    } else {
                        sideDistY = (mapY + 1.0 - player.y) * deltaDistY;
                    }

                    let hit = 0;
                    let side;

                    while (hit === 0) {
                        if (sideDistX < sideDistY) {
                            sideDistX += deltaDistX;
                            mapX += stepX;
                            side = 0;
                        } else {
                            sideDistY += deltaDistY;
                            mapY += stepY;
                            side = 1;
                        }

                        if (mapX >= 0 && mapX < mapWidth && mapY >= 0 && mapY < mapHeight && map[mapY][mapX] === '#') {
                            hit = 1;
                        } else if (mapX < 0 || mapX >= mapWidth || mapY < 0 || mapY >= mapHeight) {
                            break;
                        }
                    }

                    let perpWallDist;
                    if (hit === 1) {
                        if (side === 0) {
                            perpWallDist = (sideDistX - deltaDistX);
                        } else {
                            perpWallDist = (sideDistY - deltaDistY);
                        }
                    } else {
                        perpWallDist = 1e30;
                    }

                    const lineHeight = Math.floor(canvas.height / perpWallDist);
                    const drawStart = Math.max(0, -lineHeight / 2 + canvas.height / 2);
                    const drawEnd = Math.min(canvas.height - 1, lineHeight / 2 + canvas.height / 2);

                    let wallX;
                    if (side === 0) {
                        wallX = player.y + perpWallDist * rayDirY;
                    } else {
                        wallX = player.x + perpWallDist * rayDirX;
                    }
                    wallX -= Math.floor(wallX);

                    const texX = Math.floor(wallX * textureWidth);

                    // Calculate shading
                    const distanceShade = Math.min(1.0, 0.7 + 0.3 * (1.0 - Math.min(1.0, perpWallDist / 10.0)));
                    const sideShade = side === 1 ? 0.7 : 1.0;
                    const finalShade = distanceShade * sideShade;

                    // Draw the wall slice with texture and shading
                    if (drawEnd > drawStart) {
                        for (let y = drawStart; y < drawEnd; y++) {
                            const texY = Math.floor((y - drawStart) / lineHeight * textureHeight);
                            
                            // Get texture pixel (with wrapping)
                            const wrappedTexX = ((texX % textureWidth) + textureWidth) % textureWidth;
                            const wrappedTexY = ((texY % textureHeight) + textureHeight) % textureHeight;
                            const texIndex = (wrappedTexY * textureWidth + wrappedTexX) * 4;
                            
                            if (texIndex >= 0 && texIndex < textureData.data.length - 3) {
                                const r = textureData.data[texIndex];
                                const g = textureData.data[texIndex + 1];
                                const b = textureData.data[texIndex + 2];
                                
                                // Apply shading
                                const shadedR = Math.floor(r * finalShade);
                                const shadedG = Math.floor(g * finalShade);
                                const shadedB = Math.floor(b * finalShade);
                                
                                // Set pixel in image data
                                const pixelIndex = (y * canvas.width + x) * 4;
                                if (pixelIndex >= 0 && pixelIndex < data.length - 3) {
                                    data[pixelIndex] = shadedR;     // R
                                    data[pixelIndex + 1] = shadedG; // G
                                    data[pixelIndex + 2] = shadedB; // B
                                    data[pixelIndex + 3] = 255;     // A
                                }
                            }
                        }
                    }
                }

                // Put the image data to canvas
                ctx.putImageData(imageData, 0, 0);
            }
        };
    </script>
</body>

</html>